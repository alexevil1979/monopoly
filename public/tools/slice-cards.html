<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Monopoly — Нарезка карточек (sprite → files)</title>
    <style>
      :root {
        color-scheme: dark;
        --bg: #0b0d10;
        --panel: rgba(255, 255, 255, 0.06);
        --panel2: rgba(255, 255, 255, 0.10);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.65);
        --accent: #f4d35e;
        --accent2: #2d7d7d;
        --border: rgba(255, 255, 255, 0.12);
      }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
        background: radial-gradient(1200px 600px at 25% 20%, rgba(45, 125, 125, 0.22), transparent 60%),
          radial-gradient(1000px 600px at 80% 80%, rgba(244, 211, 94, 0.12), transparent 60%),
          var(--bg);
        color: var(--text);
      }
      .wrap {
        max-width: 980px;
        margin: 0 auto;
        padding: 24px 16px 40px;
      }
      .header {
        display: flex;
        gap: 12px;
        align-items: baseline;
        justify-content: space-between;
        flex-wrap: wrap;
        margin-bottom: 16px;
      }
      h1 {
        font-size: 18px;
        margin: 0;
        letter-spacing: 0.3px;
      }
      .hint {
        color: var(--muted);
        font-size: 13px;
      }
      .card {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 16px;
        box-shadow: 0 18px 50px rgba(0, 0, 0, 0.35);
      }
      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        margin-top: 12px;
      }
      @media (max-width: 780px) {
        .row { grid-template-columns: 1fr; }
      }
      label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 6px;
      }
      input[type="number"], textarea {
        width: 100%;
        box-sizing: border-box;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(0,0,0,0.25);
        color: var(--text);
        outline: none;
      }
      textarea { min-height: 120px; resize: vertical; }
      input[type="file"] {
        width: 100%;
      }
      .actions {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin-top: 14px;
      }
      button {
        appearance: none;
        border: 1px solid rgba(255,255,255,0.16);
        background: linear-gradient(135deg, rgba(244,211,94,0.22), rgba(45,125,125,0.18));
        color: var(--text);
        padding: 10px 14px;
        border-radius: 12px;
        cursor: pointer;
        font-weight: 700;
        letter-spacing: 0.2px;
      }
      button:disabled { opacity: 0.45; cursor: not-allowed; }
      .preview {
        margin-top: 14px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      canvas {
        width: 100%;
        height: auto;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: rgba(0,0,0,0.15);
      }
      .status {
        font-size: 13px;
        color: var(--muted);
      }
      .status strong { color: var(--accent); }
      code {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 12px;
        color: rgba(255,255,255,0.85);
      }
      .note {
        margin-top: 12px;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: var(--panel2);
        color: rgba(255,255,255,0.85);
        font-size: 13px;
        line-height: 1.45;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="header">
        <h1>Нарезка карточек из одной картинки (sprite sheet)</h1>
        <div class="hint">Открой: <code>/tools/slice-cards.html</code></div>
      </div>

      <div class="card">
        <div class="note">
          Инструмент поддерживает два варианта:
          <br />1) «Чистый спрайт»: <strong>2400×1200</strong>, сетка <strong>4×3</strong>, тайл <strong>600×400</strong>, <strong>без полей и промежутков</strong>.
          <br />2) «Фото на столе» (как у тебя): есть <strong>поля</strong> и <strong>зазоры</strong> — задай их ниже, и сетка будет нарисована поверх превью.
        </div>

        <div class="row">
          <div>
            <label>Sprite sheet (PNG/JPG)</label>
            <input id="file" type="file" accept="image/png,image/jpeg" />
          </div>
          <div>
            <label>Формат сетки</label>
            <div class="row" style="grid-template-columns: 1fr 1fr; margin-top: 0;">
              <div>
                <label style="margin-top:0;">Columns</label>
                <input id="cols" type="number" value="4" min="1" max="20" />
              </div>
              <div>
                <label style="margin-top:0;">Rows</label>
                <input id="rows" type="number" value="3" min="1" max="20" />
              </div>
            </div>
          </div>
        </div>

        <div class="row">
          <div>
            <label>Имена файлов (по одному в строке, без расширения)</label>
            <textarea id="names" spellcheck="false">go
street
chance
community_chest
tax
railroad
jail
utility
free_parking
go_to_jail
default
_extra</textarea>
            <div class="hint">`_extra` — запасной 12‑й слот (можно удалить строку).</div>
          </div>
          <div>
            <label>Куда сохранять</label>
            <div class="note">
              Скачанные файлы положи в:<br />
              <code>public/images/cards/</code><br /><br />
              Клиент сначала ищет <code>.png</code>, потом <code>.jpg</code>, потом <code>.svg</code>.
            </div>
          </div>
        </div>

        <div class="row">
          <div>
            <label>Поля и зазоры (для «фото на столе»)</label>
            <div class="row" style="grid-template-columns: 1fr 1fr; margin-top: 0;">
              <div>
                <label style="margin-top:0;">Margin X (px)</label>
                <input id="mx" type="number" value="0" min="0" max="1000" />
              </div>
              <div>
                <label style="margin-top:0;">Margin Y (px)</label>
                <input id="my" type="number" value="0" min="0" max="1000" />
              </div>
              <div>
                <label style="margin-top:0;">Gap X (px)</label>
                <input id="gx" type="number" value="0" min="0" max="1000" />
              </div>
              <div>
                <label style="margin-top:0;">Gap Y (px)</label>
                <input id="gy" type="number" value="0" min="0" max="1000" />
              </div>
            </div>
            <div class="hint">Если есть фон/промежутки — подбирай значения так, чтобы линии сетки легли точно по краям карточек.</div>
          </div>
          <div>
            <label>Размер тайла (опционально)</label>
            <div class="row" style="grid-template-columns: 1fr 1fr; margin-top: 0;">
              <div>
                <label style="margin-top:0;">Tile W (px)</label>
                <input id="tw" type="number" value="0" min="0" max="2000" />
              </div>
              <div>
                <label style="margin-top:0;">Tile H (px)</label>
                <input id="th" type="number" value="0" min="0" max="2000" />
              </div>
            </div>
            <div class="hint">Оставь 0/0 — размер вычислится автоматически из картинки, полей и зазоров.</div>
          </div>
        </div>

        <div class="actions">
          <button id="btnLoad" disabled>Загрузить и проверить</button>
          <button id="btnSlice" disabled>Нарезать и скачать всё</button>
        </div>

        <div class="preview">
          <div class="status" id="status">Выбери файл‑спрайт.</div>
          <canvas id="preview" width="1" height="1"></canvas>
        </div>
      </div>
    </div>

    <script>
      const $file = document.getElementById('file');
      const $cols = document.getElementById('cols');
      const $rows = document.getElementById('rows');
      const $mx = document.getElementById('mx');
      const $my = document.getElementById('my');
      const $gx = document.getElementById('gx');
      const $gy = document.getElementById('gy');
      const $tw = document.getElementById('tw');
      const $th = document.getElementById('th');
      const $names = document.getElementById('names');
      const $btnLoad = document.getElementById('btnLoad');
      const $btnSlice = document.getElementById('btnSlice');
      const $status = document.getElementById('status');
      const $preview = document.getElementById('preview');
      const pctx = $preview.getContext('2d');

      let img = null;

      function parseNames() {
        return $names.value
          .split('\n')
          .map(s => s.trim())
          .filter(Boolean);
      }

      function setStatus(html) {
        $status.innerHTML = html;
      }

      function computeGrid(imageWidth, imageHeight, cols, rows, mx, my, gx, gy, tw, th) {
        // if tile size not provided, compute from remaining space
        const innerW = imageWidth - (mx * 2) - (gx * (cols - 1));
        const innerH = imageHeight - (my * 2) - (gy * (rows - 1));
        const tileW = (tw && tw > 0) ? tw : innerW / cols;
        const tileH = (th && th > 0) ? th : innerH / rows;
        const ok =
          innerW > 0 &&
          innerH > 0 &&
          tileW > 0 &&
          tileH > 0 &&
          Number.isFinite(tileW) &&
          Number.isFinite(tileH) &&
          Math.abs(Math.round(tileW) - tileW) < 1e-6 &&
          Math.abs(Math.round(tileH) - tileH) < 1e-6 &&
          // total should match exactly when using integer tiles
          (mx * 2 + (cols * tileW) + (gx * (cols - 1)) === imageWidth) &&
          (my * 2 + (rows * tileH) + (gy * (rows - 1)) === imageHeight);
        return { ok, tileW: Math.round(tileW), tileH: Math.round(tileH), innerW, innerH };
      }

      async function loadImageFromFile(file) {
        const url = URL.createObjectURL(file);
        try {
          const image = new Image();
          image.decoding = 'async';
          image.src = url;
          await image.decode();
          return image;
        } finally {
          // revoke later to avoid breaking decode in some browsers
          setTimeout(() => URL.revokeObjectURL(url), 2000);
        }
      }

      function downloadBlob(blob, filename) {
        const a = document.createElement('a');
        const url = URL.createObjectURL(blob);
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 2000);
      }

      async function canvasToPngBlob(canvas) {
        return await new Promise((resolve) => canvas.toBlob(resolve, 'image/png'));
      }

      function drawPreviewGrid(image, cols, rows, mx, my, gx, gy, tileW, tileH) {
        $preview.width = image.width;
        $preview.height = image.height;
        pctx.clearRect(0, 0, $preview.width, $preview.height);
        pctx.drawImage(image, 0, 0);
        pctx.save();
        pctx.strokeStyle = 'rgba(244, 211, 94, 0.6)';
        pctx.lineWidth = Math.max(2, Math.round(image.width / 900));
        // draw tile rectangles
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const x = mx + c * (tileW + gx);
            const y = my + r * (tileH + gy);
            pctx.strokeRect(x, y, tileW, tileH);
          }
        }
        pctx.restore();
      }

      $file.addEventListener('change', () => {
        $btnLoad.disabled = !$file.files || !$file.files[0];
        $btnSlice.disabled = true;
        setStatus('Нажми <strong>Загрузить и проверить</strong>.');
      });

      $btnLoad.addEventListener('click', async () => {
        const file = $file.files && $file.files[0];
        if (!file) return;
        const cols = Math.max(1, parseInt($cols.value || '4', 10));
        const rows = Math.max(1, parseInt($rows.value || '3', 10));
        const mx = Math.max(0, parseInt($mx.value || '0', 10));
        const my = Math.max(0, parseInt($my.value || '0', 10));
        const gx = Math.max(0, parseInt($gx.value || '0', 10));
        const gy = Math.max(0, parseInt($gy.value || '0', 10));
        const tw = Math.max(0, parseInt($tw.value || '0', 10));
        const th = Math.max(0, parseInt($th.value || '0', 10));
        img = await loadImageFromFile(file);

        const { ok, tileW, tileH } = computeGrid(img.width, img.height, cols, rows, mx, my, gx, gy, tw, th);
        drawPreviewGrid(img, cols, rows, mx, my, gx, gy, tileW, tileH);

        if (!ok) {
          $btnSlice.disabled = true;
          setStatus(
            `❌ Параметры не сходятся ровно в пикселях.<br/>` +
            `Картинка: <strong>${img.width}×${img.height}</strong>, сетка <strong>${cols}×${rows}</strong>.<br/>` +
            `Попробуй подобрать <strong>Margin</strong> и <strong>Gap</strong>, чтобы рамки легли точно по карточкам.`
          );
          return;
        }

        const names = parseNames();
        const maxSlots = cols * rows;
        if (names.length > maxSlots) {
          $btnSlice.disabled = true;
          setStatus(`❌ Имен <strong>${names.length}</strong>, а слотов в сетке <strong>${maxSlots}</strong>. Уменьши список имён или увеличь сетку.`);
          return;
        }

        $btnSlice.disabled = false;
        setStatus(
          `✅ OK: <strong>${img.width}×${img.height}</strong>, сетка <strong>${cols}×${rows}</strong>, тайл <strong>${tileW}×${tileH}</strong>.<br/>` +
          `Нажми <strong>Нарезать и скачать всё</strong>.`
        );
      });

      $btnSlice.addEventListener('click', async () => {
        if (!img) return;
        const cols = Math.max(1, parseInt($cols.value || '4', 10));
        const rows = Math.max(1, parseInt($rows.value || '3', 10));
        const mx = Math.max(0, parseInt($mx.value || '0', 10));
        const my = Math.max(0, parseInt($my.value || '0', 10));
        const gx = Math.max(0, parseInt($gx.value || '0', 10));
        const gy = Math.max(0, parseInt($gy.value || '0', 10));
        const tw = Math.max(0, parseInt($tw.value || '0', 10));
        const th = Math.max(0, parseInt($th.value || '0', 10));
        const names = parseNames();
        const { ok, tileW, tileH } = computeGrid(img.width, img.height, cols, rows, mx, my, gx, gy, tw, th);
        if (!ok) return;

        const c = document.createElement('canvas');
        const ctx = c.getContext('2d');
        c.width = tileW;
        c.height = tileH;

        for (let i = 0; i < names.length; i++) {
          const name = names[i];
          const col = i % cols;
          const row = Math.floor(i / cols);
          const sx = mx + col * (tileW + gx);
          const sy = my + row * (tileH + gy);
          ctx.clearRect(0, 0, tileW, tileH);
          ctx.drawImage(img, sx, sy, tileW, tileH, 0, 0, tileW, tileH);

          const blob = await canvasToPngBlob(c);
          if (!blob) continue;
          downloadBlob(blob, `${name}.png`);
          // небольшая пауза, чтобы браузер не заблокировал “слишком много загрузок”
          await new Promise(r => setTimeout(r, 120));
        }

        setStatus(`✅ Скачано файлов: <strong>${names.length}</strong>. Перемести их в <code>public/images/cards/</code>.`);
      });
    </script>
  </body>
</html>
